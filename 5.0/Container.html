<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="UTF-8">
        <title>Learning-laravel-source-code by 5-say</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" href="../stylesheets/normalize.css" media="screen">
        <link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" media="screen">
        <link rel="stylesheet" type="text/css" href="../stylesheets/github-light.css" media="screen">
        <style>
            .l2 { margin-left: 2em; }
            .l3 { margin-left: 4em; }
            .l4 { margin-left: 6em; }
            pre a { border-bottom: dotted 2px #9FCCFC; }
            pre a:hover span { color: #6AB0F7; }
        </style>
        <link rel="stylesheet" href="../highlight/src/styles/obsidian.css">
        <script src="../highlight/src/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script src="../highlight/src/jquery-2.1.1.min.js"></script>
    </head>
    <body>
        <section class="page-header" style="padding: 0;">
            <h1 class="project-name">Learning-laravel-source-code</h1>
            <h2 class="project-tagline">Laravel 注释翻译、源码学习、完整包。</h2>
            <a href="index.html" class="btn">回到首页</a>
            <a href="https://github.com/5-say/learning-laravel-source-code/issues/new" class="btn" target="_blank">问题反馈</a>
        </section>

        <section class="main-content">

            <h2><a href="@Illuminate/Container/Container.php">Illuminate/Container/Container.php</a></h2>




<pre id="$instance"><code class="php">/**
 * The current globally available container (if any).
 * 当前全局可用的容器（如果存在）
 *
 * @var static
 */
protected static $instance;
</code></pre>

<pre id="setInstance"><code class="php">/**
 * Set the shared instance of the container.
 * 设置共享的容器实例
 *
 * @param  \Illuminate\Contracts\Container\Container  $container 容器实例
 * @return void
 */
public static function setInstance(ContainerContract $container)
{
    static::<a href="#$instance">$instance</a> = $container;
}
</code></pre>

<pre id="instance"><code class="php">/**
 * Register an existing instance as shared in the container.
 * 
 * 
 * @param  string  $abstract 抽象类
 * @param  mixed   $instance 实例
 * @return void
 */
public function instance($abstract, $instance)
{
    // First, we will extract the alias from the abstract if it is an array so we
    // 首先，如果 abstract 是一个数组，我们将从中提取别名，
    // are using the correct name when binding the type. If we get an alias it
    // 因此我们在绑定类型时使用正确的名称。如果我们得到一个别名，
    // will be registered with the container so we can resolve it out later.
    // 它将被注册到容器，这样我们可以在之后使用它。
    if (is_array($abstract))
    {
        list($abstract, $alias) = $this->extractAlias($abstract);

        $this->alias($abstract, $alias);
    }

    unset($this->aliases[$abstract]);

    // We'll check to determine if this type has been bound before, and if it has
    // 我们将检查以确定该类型之前是否已经绑定，并且如果已经绑定
    // we will fire the rebound callbacks registered with the container and it
    // 我们将触发 rebound 回调
    // can be updated with consuming classes that have gotten resolved here.
    $bound = $this->bound($abstract);

    $this->instances[$abstract] = $instance;

    if ($bound)
    {
        $this->rebound($abstract);
    }
}
</code></pre>

<pre id="rebound"><code class="php">/**
 * Fire the "rebound" callbacks for the given abstract type.
 * 触发给定抽象类型的 "rebound" 回调
 *
 * @param  string  $abstract 抽象类
 * @return void
 */
protected function rebound($abstract)
{
    $instance = $this->make($abstract);

    foreach ($this->getReboundCallbacks($abstract) as $callback)
    {
        call_user_func($callback, $this, $instance);
    }
}
</code></pre>

<pre id="make"><code class="php">/**
 * Resolve the given type from the container.
 *
 * @param  string  $abstract
 * @param  array   $parameters
 * @return mixed
 */
public function make($abstract, $parameters = [])
{
    $abstract = $this->getAlias($abstract);

    // If an instance of the type is currently being managed as a singleton we'll
    // just return an existing instance instead of instantiating new instances
    // so the developer can keep using the same objects instance every time.
    if (isset($this->instances[$abstract]))
    {
        return $this->instances[$abstract];
    }

    $concrete = $this->getConcrete($abstract);

    // We're ready to instantiate an instance of the concrete type registered for
    // the binding. This will instantiate the types, as well as resolve any of
    // its "nested" dependencies recursively until all have gotten resolved.
    if ($this->isBuildable($concrete, $abstract))
    {
        $object = $this->build($concrete, $parameters);
    }
    else
    {
        $object = $this->make($concrete, $parameters);
    }

    // If we defined any extenders for this type, we'll need to spin through them
    // and apply them to the object being built. This allows for the extension
    // of services, such as changing configuration or decorating the object.
    foreach ($this->getExtenders($abstract) as $extender)
    {
        $object = $extender($object, $this);
    }

    // If the requested type is registered as a singleton we'll want to cache off
    // the instances in "memory" so we can return it later without creating an
    // entirely new instance of an object on each subsequent request for it.
    if ($this->isShared($abstract))
    {
        $this->instances[$abstract] = $object;
    }

    $this->fireResolvingCallbacks($abstract, $object);

    $this->resolved[$abstract] = true;

    return $object;
}
</code></pre>

<pre id=""><code class="php">
</code></pre>

<pre id=""><code class="php">
</code></pre>

<pre id=""><code class="php">
</code></pre>

<pre id=""><code class="php">
</code></pre>

<pre id=""><code class="php">
</code></pre>

<pre id=""><code class="php">
</code></pre>

<pre id=""><code class="php">
</code></pre>

<pre id=""><code class="php">
</code></pre>





            <script src="main.js"></script>

        </section>



    
    </body>
</html>

